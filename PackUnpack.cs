/*********************************************************************************************************
* 模块名称: PackUnpack.cs
* 摘    要: 打包解包类
* 当前版本: 1.0.0
* 作    者: Leyutek(COPYRIGHT 2018 - 2021 Leyutek. All rights reserved.)
* 完成日期: 2021年01月10日
* 内    容: 待打包数据8个字节，打包后数据10个字节
* 注    意: none
**********************************************************************************************************
* 取代版本: 
* 作    者: 
* 完成日期: 
* 修改内容: 
* 修改文件: 
*********************************************************************************************************/
using System.Collections.Generic;

namespace FinalTest
{
    /*******************************************************************************************************
    * 类 名 称: PackUnpack 
    * 功能说明: 根据PCT协议进行打包解包
    * 注    意: 
    *******************************************************************************************************/
    class PackUnpack
    {
        //数据包的最大包长，固定为10，即1个模块ID，1个数据头，1个二级ID，6个数据，1个校验和
        public const int MAX_PACK_LEN = 10;

        public List<byte> mBufList = new List<byte>();

        static int sPackLen;           //数据包长度
        static bool sGotPackId;        //获取到ID的标志，获得正确的ID即为true，否则为false
        static int sRestByteNum;       //剩余字节数        

        /*****************************************************************************************************
        * 方法名称: packWithCheckSum  
        * 功能说明: 带校验和的数据打包
        * 参数说明：输入参数pack-原始数据包（10个字节，前8个字节为有效数据），输出参数pack-打包后数据包（10个字
        *           节）
        * 注    意: 数据头的BIT0为数据1的BIT7，数据头的BIT1为数据2的BIT7，数据头的BIT2为数据3的BIT7，以此类推 
        *****************************************************************************************************/
        private void packWithCheckSum(ref List<byte> pack)
        {
            byte dataHead;            //数据头，在打包后数据包的第二个位置，即模块ID之后
            byte checkSum;            //数据校验和，在打包后数据包的最后一个位置

            //规定包的长度为10，不为10即为错误包
            if (10 != pack.Count)
            {
                return;
            }

            checkSum = pack[0];       //取出模块ID，加到校验和
            dataHead = 0;             //数据头清零

            for (int i = 8; i > 1; i--)
            {
                //数据头左移一位后重新赋给dataHead，后面数据的最高位位于dataHead的低位
                dataHead <<= 1;

                //对数据进行最高位置1操作，并将数据位置右移一位（因为数据头要插在模块ID后面）
                pack[i] = (byte)((pack[i - 1]) | 0x80);

                //数据加到校验和，包括二级ID
                checkSum += pack[i];

                //取出原始数据的最高位，与dataHead相或
                dataHead |= (byte)(((pack[i - 1]) & 0x80) >> 7);
            }

            //数据头在打包后数据包的第二个位置，仅次于包头，数据头的最高位也要置为1
            pack[1] = (byte)(dataHead | (0x80));

            //将数据头加到校验和
            checkSum += pack[1];

            //校验和的最高位也要置为1
            pack[9] = (byte)(checkSum | 0x80);
        }

        /*****************************************************************************************************
        * 方法名称: unpackWithCheckSum
        * 功能说明: 带校验和的数据解包
        * 参数说明：输入参数listPack-待解包数据包（10个字节），输出参数listPack-解包后原始数据包（10个字节，前
        *           8个字节为有效数据），返回值0-没有获得完整数据包，1-获得完整数据包
        * 注    意: 
        *****************************************************************************************************/
        private bool unpackWithCheckSum(List<byte> listPack)
        {
            byte dataHead;
            byte checkSum;

            if (10 != listPack.Count)  //包长度不为10，返回false
            {
                return false;
            }

            checkSum = listPack[0];   //取出模块ID，加到校验和

            dataHead = listPack[1];   //取出数据包的数据头，赋给dataHead
            checkSum += dataHead;     //将数据头加到校验和

            for (int i = 1; i < 8; i++)
            {
                checkSum += listPack[i + 1];    //将数据依次加到校验和

                //还原有效的8位数据
                listPack[i] = (byte)((listPack[i + 1] & 0x7f) | ((dataHead & 0x1) << 7));

                dataHead >>= 1;                 //数据头右移一位
            }

            //判断模块ID、数据头、二级ID和数据求和的结果（低七位）是否与校验和的低七位相等，如果不等返回0
            if ((checkSum & 0x7f) != ((listPack[9]) & 0x7f))
            {
                return false;
            }

            return true;
        }

        /*****************************************************************************************************
        * 方法名称: PackUnpack
        * 功能说明: 类的构造方法，初始化该模块，将各个包的包长赋予确定的长度，其余参数均默认为0
        * 注    意:
        *****************************************************************************************************/
        public PackUnpack()
        {
            for (int i = 0; i < MAX_PACK_LEN; i++)
            {
                mBufList.Add(0);   //ID、数据头、数据及校验和均清零
            }

            sPackLen = 0;          //数据包的长度默认为0
            sGotPackId = false;    //获取到数据包ID标志默认为false，即尚未获取到ID
            sRestByteNum = 0;      //剩余的字节数默认为0 
        }

        /*****************************************************************************************************
        * 方法名称: packData  
        * 功能说明: 对数据进行打包
        * 参数说明：输入参数listPack-原始数据包（8个有效字节），输出参数listPack-打包后数据包（10个字节），
        *           返回值0-打包不成功，1-打包成功
        * 注    意: 
        *****************************************************************************************************/
        public bool packData(ref List<byte> listPack)
        {
            bool success = false;
            if (listPack[0] < 0x80)                 //数据包ID必须在0x00-0x7F之间, listPack[0]为数据包ID
            {
                while (listPack.Count < 10)         //统一待打包的数据包为10字节，不足补0，方便后续链表操作
                {
                    listPack.Add(0);
                }
                packWithCheckSum(ref listPack);
                success = true;
            }
            return success;
        }

        /*****************************************************************************************************
        * 方法名称: unpackData  
        * 功能说明: 对数据进行解包，返回大于0表示解析到一个有效包，此时通过调用getUnPackRslt函数将数据包取走，
        *           否则新数据会覆盖解析好的数据包
        * 参数说明：输入参数data-待解包数据（1个字节），输出参数mBufList-解包后数据包（8个字节），返回值0-解
        *           包不成功，1-解包成功          
        * 注    意: 
        *****************************************************************************************************/
        public bool unpackData(byte data)
        {
            bool findPack = false;

            if (sGotPackId)                        //已经接收到包ID
            {
                if (0x80 <= data)                  //包数据（非包ID）必须大于或等于0X80
                {
                    //数据包中的数据从第二个字节开始存储，因为第一个字节是包ID
                    mBufList[sPackLen] = data;
                    sPackLen++;
                    sRestByteNum--;                //剩余字节数自减

                    //已经接收到完整的数据包，包长为10
                    if (0 >= sRestByteNum && 10 == sPackLen)
                    {
                        findPack = unpackWithCheckSum(mBufList);   //接收到完整数据包后尝试解包
                        sGotPackId = false;        //清除获取到包ID标志，即重新判断下一个数据包
                    }
                }
                else
                {
                    sGotPackId = false;            //表示出错
                }
            }
            else if (data < 0x80)                  //当前的数据为包ID
            {
                sRestByteNum = 9;                  //剩余的包长，即打包好的包长减去1
                sPackLen = 1;                      //接收到包ID，即表示包长为1
                mBufList[0] = data;                //数据包的ID赋值给mBufList
                sGotPackId = true;                 //表示已经接收到包ID
            }
            return findPack;    //如果获取到完整的数据包，并解包成功，findPack为true，否则为false
        }

        /*****************************************************************************************************
        * 方法名称: getUnpackRslt  
        * 功能说明: 获取解包结果
        * 参数说明：输出参数mBufList-解包后数据包（8个字节）
        * 注    意: 
        *****************************************************************************************************/
        public List<byte> getUnpackRslt()
        {
            return (mBufList);
        }

    }
}
